{"version":3,"sources":["constants.js","components/Box.js","reducer/actions.js","reducer/reducer.js","algorithm/helper.js","algorithm/algorithms.js","components/AlgoButton.js","components/AlgoSpeed.js","components/RandomizeMazeButton.js","DrawerBar.js","algorithm/nodesFunction.js","algorithm/quickUnionFind.js","algorithm/mazeGeneration.js","App.js","reportWebVitals.js","index.js"],"names":["VW","Math","max","document","documentElement","clientWidth","window","innerWidth","VH","clientHeight","innerHeight","DRAWER_WIDTH","NUM_COL","floor","NUM_ROW","NUM_BOX","WALL","START","TARGET","EMPTY","TRAFFIC","NOT_VISITED","VISITED_PREV","VISITED_CURR","SOLUTION","ALGO_NAME","RANDOM_MAZE","BINARY_MAZE","DFS_MAZE","PRIMS_MAZE","KRUSKAL_MAZE","WALL_GEN","DivBox","styled","div","small","type","indexOf","css","state","Box","disabled","node","handleClick","updateDraggedNode","onClick","e","onMouseEnter","color","fontSize","background","SET_ALGO","SET_STEP","SET_ALGO_STATUS","SET_MAZE_GEN","SET_MAZE_GEN_STATUS","RUNNING","algoReducer","action","newState","algo","payload","step","status","maze_gen","maze_gen_status","getXYFromIndex","index","y","x","isValidLocation","nodes","ignoreWall","getIndexFromXY","indexIsWall","getNeighbor","neighbors","filter","pos","map","getPathNeighbor","xWall","yWall","n","w","shuffle","array","i","length","j","random","temp","MAX_DIST","dfsAlgo","startId","targetId","steps","algoMemoryObj","pathMap","undefined","marked","Set","lastVisited","deque","count","copyNodes","currentlyVisited","nodeIndex","pop","solved","inProgress","solution","markAsVisitedPrev","concat","solutionList","getSolutionList","push","has","add","neighborId","forEach","interimObj","bfsAlgo","algoType","distanceMap","pq","Heapify","distanceToN","getDistanceToNeighbor","getDistance","distanceToNeighbor","getHeuristic","size","currentNode","targetNode","x1","y1","x2","y2","sqrt","distMap","ls","tmp","tempNodes","algoList","Object","keys","AlgoButton","props","dispatch","useContext","DispatchContext","StateContext","React","useState","open","setOpen","anchorRef","useRef","handleClose","event","current","contains","target","Grid","container","direction","alignItems","item","xs","style","width","ButtonGroup","variant","ref","fullWidth","Button","onButtonClick","startIcon","prevOpen","Popper","anchorEl","role","transition","disablePortal","position","zIndex","TransitionProps","placement","Grow","transformOrigin","Paper","ClickAwayListener","onClickAway","MenuList","id","option","MenuItem","selected","parseInt","marks","value","label","Array","from","_","useStyles","makeStyles","root","slider","marginLeft","marginRight","AlgoSpeed","classes","className","Typography","gutterBottom","Slider","onChange","newValue","min","RandomizeMazeButton","theme","appBar","drawer","flexShrink","drawerPaper","toolbar","mixins","mainHeader","headerLogo","margin","display","justifyContent","iconMargin","alignSelf","content","flexGrow","backgroundColor","palette","default","padding","spacing","infoIcon","listItemText","DrawerBar","infoList","informations","info","primaryText","tooltip","Tooltip","title","arrow","InfoOutlined","Drawer","paper","anchor","List","ListItem","handleAddMaze","onRunAlgoClick","Divider","ListItemIcon","ListItemText","primary","handleClearNodes","handleAddRandomTrafficNodes","InfoRounded","dense","clearNodes","nodeList","nodeType","reduce","accum","key","clearNode","nextType","QuickUnionFind","this","disjointSets","nodeId","isConnected","smallerOne","biggerOne","findParent","subParent","generateUnconnectedNodes","startingPoint","visited","walls","stack","nIndex","neighbor","wallIndex","n1Index","n2Index","START_NODE","TARGET_NODE","MazeRoot","createContext","App","boxMap","initializeNodes","setNodeList","startNode","setStartNode","setTargetNode","val","dragging","setDragging","intervalId","setIntervalId","setSolutionList","wallList","setWallList","useReducer","boxList","useMemo","useEffect","prevNodeList","sIndex","inverse","updateNode","Provider","currentType","nextState","clearInterval","updatedNodeList","resetNodeState","newIntervalId","setInterval","rSolved","rInProgress","prevNodes","addRandomTrafficNodes","pathList","initialPoint","path","pathIndex","filteredNeighbors","reverse","generateDfsMaze","generateRandomMaze","initialNodes","westNode","southNode","westPath","southPath","isWestValidLocation","isNorthValidLocation","generateBinaryMaze","generatePrimsMaze","quickUnionFind","edgesCount","connect","generateKruskalMaze","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.936add58.chunk.js","sourcesContent":["export const VW = Math.max(\n  document.documentElement.clientWidth || 0,\n  window.innerWidth || 0\n);\nexport const VH = Math.max(\n  document.documentElement.clientHeight || 0,\n  window.innerHeight || 0\n);\n\nconst MIN_ROW = 10;\nconst MIN_COL = 20;\n\nexport const DRAWER_WIDTH = 300;\nexport const NUM_COL = Math.max(\n  MIN_COL,\n  Math.floor((VW - DRAWER_WIDTH) / 32.5)\n);\nexport const NUM_ROW = Math.max(MIN_ROW, Math.floor(VH / 32.5));\nexport const NUM_BOX = NUM_COL * NUM_ROW;\n\nexport const WALL = \"wall\";\nexport const START = \"start\";\nexport const TARGET = \"target\";\nexport const EMPTY = \"empty\";\nexport const TRAFFIC = \"traffic\";\n\nexport const NOT_VISITED = \"not_visited\";\nexport const VISITED_PREV = \"visited_prev\";\nexport const VISITED_CURR = \"visited_curr\";\nexport const SOLUTION = \"solution\";\n\nexport const BFS = 1;\nexport const DJIKSTRA = 2;\nexport const A_STAR = 3;\nexport const DFS = 4;\n\nexport const ALGO_NAME = {\n  [DFS]: \"DFS\",\n  [BFS]: \"BFS\",\n  [DJIKSTRA]: \"DJIKSTRA\",\n  [A_STAR]: \"A*\",\n};\n\nexport const RANDOM_MAZE = \"Random Maze\";\nexport const BINARY_MAZE = \"Binary Maze\";\nexport const DFS_MAZE = \"DFS Maze\";\nexport const PRIMS_MAZE = \"Prim's Maze\";\nexport const KRUSKAL_MAZE = \"Kruskal Maze\";\nexport const WALL_GEN = [DFS_MAZE, PRIMS_MAZE, BINARY_MAZE, KRUSKAL_MAZE, RANDOM_MAZE];\n","import React from \"react\";\nimport PlayCircleFilledIcon from \"@material-ui/icons/PlayCircleFilled\";\nimport TrackChangesIcon from \"@material-ui/icons/TrackChanges\";\nimport TrafficIcon from \"@material-ui/icons/Traffic\";\nimport styled, { css } from \"styled-components\";\nimport {\n  SOLUTION,\n  START,\n  TARGET,\n  VISITED_PREV,\n  VISITED_CURR,\n  WALL,\n  TRAFFIC,\n} from \"../constants\";\n\nconst DivBox = styled.div`\n  background: white;\n  border-radius: 0px;\n  border: 0.5px solid lightblue;\n  height: 30px;\n  width: 30px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 30px;\n  color: darkgray;\n\n  ${({ small, type }) => {\n    if (small && [START, TRAFFIC, TARGET].indexOf(type) !== -1) {\n      return css`\n        height: 20px;\n        width: 20px;\n        font-size: 25px;\n        border: transparent;\n        background: transparent;\n      `;\n    } else if (small) {\n      return css`\n        height: 20px;\n        width: 20px;\n        font-size: 25px;\n      `;\n    }\n  }};\n\n  ${({ type }) => {\n    if (type === TRAFFIC) {\n      return css`\n        color: lightgray;\n      `;\n    } else if (type === WALL) {\n      return css`\n        background: black;\n        border: 0.5px solid black;\n        -webkit-transition: background-color 1000ms linear;\n        -ms-transition: background-color 1000ms linear;\n        transition: background-color 1000ms linear;\n      `;\n    } else if (type === TARGET || type === START) {\n      return css`\n        background: transparent;\n      `;\n    }\n  }};\n\n  ${({ state }) => {\n    if (state === VISITED_PREV) {\n      return css`\n        background-color: lightsteelblue;\n        -webkit-transition: background-color 400ms linear;\n        -ms-transition: background-color 400ms linear;\n        transition: background-color 400ms linear;\n      `;\n    } else if (state === VISITED_CURR) {\n      return css`\n        background: steelblue;\n      `;\n    } else if (state === SOLUTION) {\n      return css`\n        background: lightseagreen;\n        color: black;\n      `;\n    }\n  }};\n`;\n\nconst Box = ({\n  disabled,\n  small,\n  node,\n  type,\n  state,\n  handleClick,\n  updateDraggedNode,\n}) => {\n  return (\n    <DivBox\n      type={type}\n      state={state}\n      small={small}\n      onClick={(e) => !disabled && handleClick(e)}\n      onMouseEnter={() => !disabled && updateDraggedNode(node)}\n    >\n      {type === START && (\n        <PlayCircleFilledIcon\n          color={\"inherit\"}\n          fontSize={\"inherit\"}\n          background=\"inherit\"\n        />\n      )}\n      {type === TARGET && (\n        <TrackChangesIcon\n          color={\"inherit\"}\n          fontSize={\"inherit\"}\n          background=\"inherit\"\n        />\n      )}\n      {type === TRAFFIC && (\n        <TrafficIcon\n          color={\"inherit\"}\n          fontSize={\"inherit\"}\n          background=\"inherit\"\n        />\n      )}\n    </DivBox>\n  );\n};\n\nexport default Box;\n","export const SET_ALGO = 'set_algo'\nexport const SET_STEP = 'set_step'\nexport const SET_ALGO_STATUS = 'set_algo_status'\n\nexport const SET_MAZE_GEN = 'set_maze_gen'\nexport const SET_MAZE_GEN_STATUS = 'set_maze_gen_status'\n\n\nexport const RUNNING = 'running'\nexport const GENERATING_MAZE = false","import {\n  SET_ALGO,\n  SET_ALGO_STATUS,\n  SET_MAZE_GEN,\n  SET_MAZE_GEN_STATUS,\n  SET_STEP,\n} from \"./actions\";\n\nexport const algoReducer = (state = [], action) => {\n  switch (action.type) {\n    case SET_ALGO:\n      const newState = { ...state, algo: action.payload };\n      return newState;\n    case SET_STEP:\n      return { ...state, step: action.payload };\n    case SET_ALGO_STATUS:\n      return { ...state, status: action.payload };\n    case SET_MAZE_GEN:\n      return { ...state, maze_gen: action.payload };\n    case SET_MAZE_GEN_STATUS:\n      return { ...state, maze_gen_status: action.payload };\n    default:\n      return state;\n  }\n};\n","import { NUM_COL, NUM_ROW, WALL } from \"../constants\";\n\nexport const getXYFromIndex = (index) => {\n  const y = Math.floor(index / NUM_COL);\n  const x = index % NUM_COL;\n\n  return { x, y };\n};\n\nexport const isValidLocation = ({ x, y }, nodes, ignoreWall = false) => {\n  const index = getIndexFromXY({ x, y });\n  const indexIsWall = nodes[index]?.type !== WALL;\n\n  return (\n    0 <= x &&\n    x < NUM_COL &&\n    0 <= y &&\n    y < NUM_ROW &&\n    (ignoreWall || indexIsWall)\n  );\n};\n\nexport const getIndexFromXY = ({ x, y }) => y * NUM_COL + x;\n\n// Ignore diagonal\nexport const getNeighbor = (nodes, index, step = 1, ignoreWall = false) => {\n  const { x, y } = getXYFromIndex(index);\n\n  const neighbors = [\n    { x: x + step, y: y },\n    { x: x - step, y: y },\n    { x: x, y: y + step },\n    { x: x, y: y - step },\n  ];\n\n  return neighbors\n    .filter((pos) => isValidLocation(pos, nodes, ignoreWall))\n    .map((pos) => getIndexFromXY(pos));\n};\n\nexport const getPathNeighbor = (index, step = 2) => {\n  const { x, y } = getXYFromIndex(index);\n\n  const neighbors = [\n    { x: x + step, y: y, xWall: x + 1, yWall: y },\n    { x: x - step, y: y, xWall: x - 1, yWall: y },\n    { x: x, y: y + step, xWall: x, yWall: y + 1 },\n    { x: x, y: y - step, xWall: x, yWall: y - 1 },\n  ];\n\n  return neighbors\n    .filter((pos) => isValidLocation(pos, {}, true))\n    .map((pos) => ({\n      n: getIndexFromXY(pos),\n      w: getIndexFromXY({ x: pos.xWall, y: pos.yWall }),\n    }));\n};\n\n\nexport function shuffle(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n      var j = Math.floor(Math.random() * (i + 1));\n      var temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n  }\n}","import Heapify from \"heapify\";\nimport {\n  A_STAR,\n  DFS,\n  DJIKSTRA,\n  NUM_COL,\n  NUM_ROW,\n  TRAFFIC,\n  VISITED_CURR,\n  VISITED_PREV,\n} from \"../constants\";\nimport { getNeighbor, getXYFromIndex } from \"./helper\";\n\nconst MAX_DIST = 99999999999;\n\nexport const algo = (\n  nodes,\n  startId,\n  targetId,\n  algoType = DJIKSTRA,\n  steps = MAX_DIST,\n  algoMemoryObj\n) => {\n  if (algoType === DFS) {\n    return dfsAlgo(nodes, startId, targetId, algoType, steps, algoMemoryObj);\n  } else {\n    return bfsAlgo(nodes, startId, targetId, algoType, steps, algoMemoryObj);\n  }\n};\n\nconst dfsAlgo = (\n  nodes,\n  startId,\n  targetId,\n  algoType = DFS,\n  steps = MAX_DIST,\n  algoMemoryObj\n) => {\n  let pathMap = algoMemoryObj.pathMap || { [startId]: undefined };\n  let marked = algoMemoryObj.marked || new Set();\n  let lastVisited = algoMemoryObj.lastVisited || [];\n  let deque = algoMemoryObj.deque || [startId];\n\n  let count = 0;\n  let copyNodes = { ...nodes };\n  let currentlyVisited = [];\n\n  while (deque.length > 0 && count < steps) {\n    const nodeIndex = deque.pop();\n\n    count += 1;\n\n    if (targetId === nodeIndex) {\n      copyNodes = markAsVisitedPrev(\n        lastVisited.concat(currentlyVisited),\n        copyNodes\n      );\n      return {\n        solved: true,\n        inProgress: false,\n        solution: copyNodes,\n        solutionList: getSolutionList(pathMap, startId, targetId),\n      };\n    } else {\n      currentlyVisited.push(nodeIndex);\n      copyNodes[nodeIndex].state = VISITED_CURR;\n    }\n\n    if (!marked.has(nodeIndex)) {\n      marked.add(nodeIndex);\n      getNeighbor(copyNodes, nodeIndex)\n        .filter((neighborId) => !marked.has(neighborId))\n        .forEach((neighborId) => {\n          pathMap[neighborId] = nodeIndex;\n          deque.push(neighborId);\n        });\n    }\n  }\n\n  if (count === steps) {\n    copyNodes = markAsVisitedPrev(lastVisited, copyNodes);\n\n    return {\n      solved: false,\n      inProgress: true,\n      solution: copyNodes,\n      interimObj: {\n        pathMap,\n        marked,\n        lastVisited: currentlyVisited,\n        deque,\n      },\n    };\n  }\n\n  return { solved: false, inProgress: false, solution: copyNodes };\n};\n\nconst bfsAlgo = (\n  nodes,\n  startId,\n  targetId,\n  algoType = DJIKSTRA,\n  steps = MAX_DIST,\n  algoMemoryObj\n) => {\n  let distanceMap = algoMemoryObj.distanceMap || { [startId]: 0 };\n  let pathMap = algoMemoryObj.pathMap || { [startId]: undefined };\n  let marked = algoMemoryObj.marked || new Set();\n  let pq = algoMemoryObj.pq || new Heapify(NUM_COL * NUM_ROW);\n  let lastVisited = algoMemoryObj.lastVisited || [];\n\n  let count = 0;\n  let copyNodes = { ...nodes };\n  let currentlyVisited = [];\n\n  while (pq.size !== 0 && count < steps) {\n    const nodeIndex = pq.pop();\n    marked.add(nodeIndex);\n\n    if (targetId === nodeIndex) {\n      copyNodes = markAsVisitedPrev(\n        lastVisited.concat(currentlyVisited),\n        copyNodes\n      );\n      return {\n        solved: true,\n        inProgress: false,\n        solution: copyNodes,\n        solutionList: getSolutionList(pathMap, startId, targetId),\n      };\n    } else {\n      currentlyVisited.push(nodeIndex);\n      copyNodes[nodeIndex].state = VISITED_CURR;\n    }\n\n    count += 1;\n\n    const distanceToN = distanceMap[nodeIndex] || 0;\n    getNeighbor(copyNodes, nodeIndex)\n      .filter((neighborId) => !marked.has(neighborId))\n      .filter(\n        (neighborId) =>\n          distanceToN + getDistanceToNeighbor(algoType, nodes, neighborId) <\n          getDistance(distanceMap, neighborId)\n      )\n      .forEach((neighborId) => {\n        const distanceToNeighbor = getDistanceToNeighbor(\n          algoType,\n          nodes,\n          neighborId\n        );\n        distanceMap[neighborId] = distanceToN + distanceToNeighbor;\n        pathMap[neighborId] = nodeIndex;\n\n        pq.push(\n          neighborId,\n          distanceToN +\n            distanceToNeighbor +\n            getHeuristic(algoType, neighborId, targetId)\n        );\n      });\n  }\n\n  if (count === steps) {\n    copyNodes = markAsVisitedPrev(lastVisited, copyNodes);\n\n    return {\n      solved: false,\n      inProgress: true,\n      solution: copyNodes,\n      interimObj: {\n        distanceMap,\n        pathMap,\n        marked,\n        pq,\n        lastVisited: currentlyVisited,\n      },\n    };\n  }\n\n  return { solved: false, inProgress: false, solution: copyNodes };\n};\n\nconst getDistanceToNeighbor = (algoType, nodes, neighborId) => {\n  if (algoType === A_STAR || algoType === DJIKSTRA) {\n    return nodes[neighborId].type === TRAFFIC ? 3 : 1;\n  }\n  return 1;\n};\n\nconst getHeuristic = (algoType, currentNode, targetNode) => {\n  if (algoType === A_STAR) {\n    const { x: x1, y: y1 } = getXYFromIndex(currentNode);\n    const { x: x2, y: y2 } = getXYFromIndex(targetNode);\n\n    return Math.floor(Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2));\n  }\n  return 0;\n};\n\nconst getDistance = (distMap, index) => {\n  return distMap[index] === undefined ? MAX_DIST : distMap[index];\n};\n\nconst getSolutionList = (pathMap, startId, targetId) => {\n  let ls = [targetId];\n  let tmp = pathMap[targetId];\n  while (tmp && tmp !== startId) {\n    ls = ls.concat(tmp);\n    tmp = pathMap[tmp];\n  }\n  ls = ls.concat(startId);\n\n  return ls;\n};\n\nconst markAsVisitedPrev = (lastVisited, nodes) => {\n  let tempNodes = { ...nodes };\n  for (const index of lastVisited) {\n    tempNodes[index] = {\n      ...tempNodes[index],\n      state: VISITED_PREV,\n    };\n  }\n\n  return tempNodes;\n};\n\n/*\nconst getSolution = (nodes, pathMap, startId, targetId) => {\n  let tmpNodes = { ...nodes };\n  let tmp = pathMap[targetId];\n  while (tmp && tmp !== startId) {\n    tmpNodes[tmp] = { ...tmpNodes[tmp], state: SOLUTION };\n    tmp = pathMap[tmp];\n  }\n  tmpNodes[startId] = { ...tmpNodes[startId], state: SOLUTION };\n  tmpNodes[targetId] = { ...tmpNodes[targetId], state: SOLUTION };\n\n  return tmpNodes;\n};\n*/\n","import React, { useContext } from \"react\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Button from \"@material-ui/core/Button\";\nimport ButtonGroup from \"@material-ui/core/ButtonGroup\";\nimport ArrowDropDownIcon from \"@material-ui/icons/ArrowDropDown\";\nimport ClickAwayListener from \"@material-ui/core/ClickAwayListener\";\nimport Grow from \"@material-ui/core/Grow\";\nimport Paper from \"@material-ui/core/Paper\";\nimport Popper from \"@material-ui/core/Popper\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport MenuList from \"@material-ui/core/MenuList\";\nimport NavigationIcon from \"@material-ui/icons/Navigation\";\nimport { DispatchContext, StateContext } from \"../App\";\nimport { ALGO_NAME } from \"../constants\";\nimport { SET_ALGO, RUNNING } from \"../reducer/actions\";\n\nconst algoList = Object.keys(ALGO_NAME);\n\nconst AlgoButton = (props) => {\n  const dispatch = useContext(DispatchContext);\n  const state = useContext(StateContext);\n  const [open, setOpen] = React.useState(false);\n  const anchorRef = React.useRef(null);\n\n  const handleMenuItemClick = (algo) => {\n    dispatch({ type: SET_ALGO, payload: parseInt(algo) });\n    setOpen(false);\n  };\n\n  const handleToggle = () => {\n    setOpen((prevOpen) => !prevOpen);\n  };\n\n  const handleClose = (event) => {\n    if (anchorRef.current && anchorRef.current.contains(event.target)) {\n      return;\n    }\n\n    setOpen(false);\n  };\n\n  return (\n    <Grid container direction=\"column\" alignItems=\"center\">\n      <Grid item xs={12} style={{ width: \"100%\" }}>\n        <ButtonGroup\n          variant=\"contained\"\n          color=\"primary\"\n          ref={anchorRef}\n          aria-label=\"split button\"\n          style={{ width: \"100%\" }}\n          fullWidth\n        >\n          <Button\n            onClick={props.onButtonClick}\n            startIcon={<NavigationIcon />}\n            fullWidth\n          >\n            {`${state.status === RUNNING ? \"Stop\" : \"Run\"} ${\n              ALGO_NAME[state.algo]\n            }`}\n          </Button>\n          <Button\n            color=\"primary\"\n            size=\"small\"\n            aria-controls={open ? \"split-button-menu\" : undefined}\n            aria-expanded={open ? \"true\" : undefined}\n            aria-label=\"select merge strategy\"\n            aria-haspopup=\"menu\"\n            onClick={handleToggle}\n            style={{ width: \"15px\" }}\n          >\n            <ArrowDropDownIcon />\n          </Button>\n        </ButtonGroup>\n        <Popper\n          open={open}\n          anchorEl={anchorRef.current}\n          role={undefined}\n          transition\n          disablePortal\n          style={{ position: \"relative\", zIndex: 999 }}\n        >\n          {({ TransitionProps, placement }) => (\n            <Grow\n              {...TransitionProps}\n              style={{\n                transformOrigin:\n                  placement === \"bottom\" ? \"center top\" : \"center bottom\",\n              }}\n            >\n              <Paper>\n                <ClickAwayListener onClickAway={handleClose}>\n                  <MenuList id=\"split-button-menu\">\n                    {algoList.map((option) => (\n                      <MenuItem\n                        key={option}\n                        selected={state.algo === option}\n                        onClick={() => handleMenuItemClick(option)}\n                      >\n                        {ALGO_NAME[option]}\n                      </MenuItem>\n                    ))}\n                  </MenuList>\n                </ClickAwayListener>\n              </Paper>\n            </Grow>\n          )}\n        </Popper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default AlgoButton;\n","import React, { useContext } from \"react\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Slider from \"@material-ui/core/Slider\";\nimport { DispatchContext, StateContext } from \"../App\";\nimport { SET_STEP } from \"../reducer/actions\";\n\nconst marks = [\n  {\n    value: 1,\n    label: 1,\n  },\n  {\n    value: 2,\n  },\n]\n  .concat(Array.from({ length: 19 }, (_, i) => ({ value: (i + 1) * 5 })))\n  .concat({\n    value: 100,\n    label: 100,\n  });\n\nconst useStyles = makeStyles({\n  root: {\n    width: \"90%\",\n  },\n  slider: {\n    marginLeft: \"10px\",\n    marginRight: \"10px\",\n  },\n});\n\nexport default function AlgoSpeed() {\n  const classes = useStyles();\n  const dispatch = useContext(DispatchContext);\n  const state = useContext(StateContext);\n\n  const handleChange = (event, newValue) => {\n    if (newValue !== state.step) {\n      dispatch({ type: SET_STEP, payload: newValue });\n    }\n  };\n\n  return (\n    <div className={classes.root}>\n      <Typography id=\"discrete-slider-restrict\" gutterBottom>\n        Speed\n      </Typography>\n      <Slider\n        value={state.step}\n        onChange={handleChange}\n        aria-labelledby=\"discrete-slider-restrict\"\n        step={null}\n        min={1}\n        max={100}\n        marks={marks}\n        className={classes.slider}\n      />\n    </div>\n  );\n}\n","import React, { useContext } from \"react\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Button from \"@material-ui/core/Button\";\nimport ButtonGroup from \"@material-ui/core/ButtonGroup\";\nimport ArrowDropDownIcon from \"@material-ui/icons/ArrowDropDown\";\nimport ClickAwayListener from \"@material-ui/core/ClickAwayListener\";\nimport AccountTreeIcon from \"@material-ui/icons/AccountTree\";\nimport Grow from \"@material-ui/core/Grow\";\nimport Paper from \"@material-ui/core/Paper\";\nimport Popper from \"@material-ui/core/Popper\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport MenuList from \"@material-ui/core/MenuList\";\nimport { DispatchContext, StateContext } from \"../App\";\nimport { WALL_GEN } from \"../constants\";\nimport { SET_MAZE_GEN } from \"../reducer/actions\";\n\nconst RandomizeMazeButton = (props) => {\n  const dispatch = useContext(DispatchContext);\n  const state = useContext(StateContext);\n  const [open, setOpen] = React.useState(false);\n  const anchorRef = React.useRef(null);\n\n  const handleMenuItemClick = (algo) => {\n    dispatch({ type: SET_MAZE_GEN, payload: algo });\n    setOpen(false);\n  };\n\n  const handleToggle = () => {\n    setOpen((prevOpen) => !prevOpen);\n  };\n\n  const handleClose = (event) => {\n    if (anchorRef.current && anchorRef.current.contains(event.target)) {\n      return;\n    }\n\n    setOpen(false);\n  };\n\n  return (\n    <Grid\n      container\n      direction=\"column\"\n      alignItems=\"center\"\n      style={{ width: \"100%\" }}\n    >\n      <Grid item xs={12} style={{ width: \"100%\" }}>\n        <ButtonGroup\n          variant=\"contained\"\n          color=\"primary\"\n          ref={anchorRef}\n          aria-label=\"split button\"\n          fullWidth\n        >\n          <Button\n            onClick={props.onButtonClick}\n            fullWidth\n            startIcon={<AccountTreeIcon />}\n          >\n            {`${state.maze_gen_status ? \"Stop\" : \"Create\"} ${state.maze_gen}`}\n          </Button>\n          <Button\n            color=\"primary\"\n            size=\"small\"\n            aria-controls={open ? \"split-button-menu\" : undefined}\n            aria-expanded={open ? \"true\" : undefined}\n            aria-label=\"select merge strategy\"\n            aria-haspopup=\"menu\"\n            onClick={handleToggle}\n            style={{ width: \"15px\" }}\n          >\n            <ArrowDropDownIcon />\n          </Button>\n        </ButtonGroup>\n        <Popper\n          open={open}\n          anchorEl={anchorRef.current}\n          role={undefined}\n          transition\n          disablePortal\n          style={{ position: \"relative\", zIndex: 999 }}\n        >\n          {({ TransitionProps, placement }) => (\n            <Grow\n              {...TransitionProps}\n              style={{\n                transformOrigin:\n                  placement === \"bottom\" ? \"center top\" : \"center bottom\",\n              }}\n            >\n              <Paper>\n                <ClickAwayListener onClickAway={handleClose}>\n                  <MenuList id=\"split-button-menu\">\n                    {WALL_GEN.map((option) => (\n                      <MenuItem\n                        key={option}\n                        selected={state.maze_gen === option}\n                        onClick={() => handleMenuItemClick(option)}\n                      >\n                        {option}\n                      </MenuItem>\n                    ))}\n                  </MenuList>\n                </ClickAwayListener>\n              </Paper>\n            </Grow>\n          )}\n        </Popper>\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default RandomizeMazeButton;\n","import React from \"react\";\nimport {\n  Drawer,\n  makeStyles,\n  List,\n  ListItem,\n  Divider,\n  Button,\n  Typography,\n  Tooltip,\n} from \"@material-ui/core\";\nimport \"@fontsource/roboto\";\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport SettingsIcon from \"@material-ui/icons/Settings\";\nimport BlurOnIcon from \"@material-ui/icons/BlurOn\";\nimport Box from \"./components/Box\";\nimport {\n  DRAWER_WIDTH,\n  SOLUTION,\n  START,\n  TARGET,\n  TRAFFIC,\n  VISITED_CURR,\n  VISITED_PREV,\n  WALL,\n} from \"./constants\";\nimport AlgoButton from \"./components/AlgoButton\";\nimport AlgoSpeed from \"./components/AlgoSpeed\";\nimport RandomizeMazeButton from \"./components/RandomizeMazeButton\";\nimport { InfoOutlined, InfoRounded } from \"@material-ui/icons\";\n\nconst useStyles = makeStyles((theme) => ({\n  appBar: {\n    width: `calc(100% - ${DRAWER_WIDTH}px)`,\n    marginRight: DRAWER_WIDTH,\n  },\n  drawer: {\n    width: DRAWER_WIDTH,\n    flexShrink: 0,\n  },\n  drawerPaper: {\n    width: DRAWER_WIDTH,\n    background: \"#EFEFEF\",\n  },\n  // necessary for content to be below app bar\n  toolbar: theme.mixins.toolbar,\n  mainHeader: {\n    background: \"#393939\",\n  },\n  headerLogo: {\n    margin: \"20px\",\n    display: \"flex\",\n    color: \"#EFEFEF\",\n    justifyContent: \"center\",\n  },\n  iconMargin: { alignSelf: \"center\", marginRight: \"5px\" },\n  content: {\n    flexGrow: 1,\n    backgroundColor: theme.palette.background.default,\n    padding: theme.spacing(3),\n  },\n  infoIcon: { alignSelf: \"center\", marginLeft: \"5px\" },\n  listItemText: { display: \"flex\" },\n}));\n\nconst DrawerBar = (props) => {\n  const classes = useStyles();\n\n  const infoList = informations.map((info) => ({\n    type: info.type,\n    state: info.state,\n    primaryText: info.tooltip ? (\n      <div className={classes.listItemText}>\n        {info.primaryText}\n        <Tooltip title={info.tooltip} arrow>\n          <InfoOutlined fontSize=\"inherit\" className={classes.infoIcon} />\n        </Tooltip>\n      </div>\n    ) : (\n      info.primaryText\n    ),\n  }));\n\n  return (\n    <>\n      <Drawer\n        className={classes.drawer}\n        variant=\"permanent\"\n        color=\"secondary\"\n        classes={{\n          paper: classes.drawerPaper,\n        }}\n        anchor=\"right\"\n      >\n        <div className={classes.mainHeader}>\n          <Typography variant={\"h4\"} className={classes.headerLogo}>\n            <BlurOnIcon fontSize=\"inherit\" className={classes.iconMargin} />\n            <b>Maze & Paths</b>\n          </Typography>\n        </div>\n\n        <List>\n          <ListItem>\n            <RandomizeMazeButton onButtonClick={props.handleAddMaze} />\n          </ListItem>\n          <ListItem>\n            <AlgoButton onButtonClick={props.onRunAlgoClick} />\n          </ListItem>\n        </List>\n\n        <Divider />\n\n        <List>\n          <ListItem>\n            <ListItemIcon>\n              <SettingsIcon />\n            </ListItemIcon>\n            <ListItemText primary=\"Algorithm Settings\" />\n          </ListItem>\n          <ListItem>\n            <AlgoSpeed />\n          </ListItem>\n        </List>\n        <Divider />\n\n        <List>\n          <ListItem>\n            <Button\n              variant=\"outlined\"\n              onClick={props.handleClearNodes}\n              color=\"primary\"\n              fullWidth\n            >\n              {`Clear Board`}\n            </Button>\n          </ListItem>\n\n          <ListItem>\n            <Button\n              variant=\"outlined\"\n              onClick={props.handleAddRandomTrafficNodes}\n              color=\"primary\"\n              fullWidth\n            >\n              {`Add Random Traffic`}\n            </Button>\n          </ListItem>\n        </List>\n        <Divider />\n        <List>\n          <ListItem>\n            <ListItemIcon>\n              <InfoRounded />\n            </ListItemIcon>\n            <ListItemText primary=\"Information\" />\n          </ListItem>\n          <List dense>\n            {infoList.map((item) => (\n              <ListItem>\n                <ListItemText primary={item.primaryText} />\n                <Box\n                  small\n                  disabled={true}\n                  type={item.type}\n                  state={item.state}\n                />\n              </ListItem>\n            ))}\n          </List>\n        </List>\n      </Drawer>\n    </>\n  );\n};\n\nexport default DrawerBar;\n\nconst informations = [\n  { primaryText: \"Empty Node\" },\n  {\n    primaryText: \"Wall Node\",\n    tooltip:\n      \"Wall Node is impenetrable. Click on any empty node to add a wall.\",\n    type: WALL,\n  },\n  {\n    primaryText: \"Traffic Node\",\n    tooltip: \"Traffic Node costs 3x more to traverse\",\n    type: TRAFFIC,\n  },\n  {\n    primaryText: \"Start Node\",\n    tooltip: \"Click the start node icon to move it around\",\n    type: START,\n  },\n  {\n    primaryText: \"Target Node\",\n    tooltip: \"Click the target node icon to move it around\",\n    type: TARGET,\n  },\n  {\n    primaryText: \"Currently Node\",\n    state: VISITED_CURR,\n  },\n  {\n    primaryText: \"Visited Node\",\n    state: VISITED_PREV,\n  },\n  {\n    primaryText: \"Solution\",\n    state: SOLUTION,\n  },\n];\n","import { EMPTY, NOT_VISITED, START, TARGET, TRAFFIC, WALL } from \"../constants\";\n\nexport const initializeNodes = (START_NODE, TARGET_NODE, NUM_BOX) => {\n  const boxMap = {};\n\n  for (let i = 0; i < NUM_BOX; i++) {\n    boxMap[i] = {\n      type: i === START_NODE ? START : i === TARGET_NODE ? TARGET : EMPTY,\n    };\n  }\n\n  return boxMap;\n};\n\nexport const resetNodeState = (nodeList) => {\n  return Object.keys(nodeList).reduce((accum, key) => {\n    accum[key] = {\n      ...nodeList[key],\n      state: NOT_VISITED,\n    };\n    return accum;\n  }, {});\n};\n\nexport const addRandomWallNodes = (nodeList) => {\n  const cleanNodes = clearNodes(nodeList);\n\n  return Object.keys(cleanNodes).reduce((accum, key) => {\n    const type = cleanNodes[key].type;\n    if (Math.random() < 0.35 && type !== START && type !== TARGET) {\n      accum[key] = {\n        ...cleanNodes[key],\n        type: WALL,\n        state: NOT_VISITED,\n      };\n    } else {\n      accum[key] = { ...cleanNodes[key] };\n    }\n\n    return accum;\n  }, {});\n};\n\nexport const addRandomTrafficNodes = (nodeList) => {\n  return Object.keys(nodeList).reduce((accum, key) => {\n    const type = nodeList[key].type;\n    if (Math.random() < 0.2 && type === EMPTY) {\n      accum[key] = {\n        ...nodeList[key],\n        type: TRAFFIC,\n        state: NOT_VISITED,\n      };\n    } else {\n      accum[key] = { ...nodeList[key] };\n    }\n\n    return accum;\n  }, {});\n};\n\nexport const clearNodes = (nodeList, nodeType = EMPTY) => {\n  return Object.keys(nodeList).reduce((accum, key) => {\n    accum[key] = clearNode(nodeList[key], nodeType);\n    return accum;\n  }, {});\n};\n\nexport const clearNode = (node, nodeType) => {\n  const type = node.type;\n  const nextType = type === START || type === TARGET ? type : nodeType;\n  return { ...node, state: NOT_VISITED, type: nextType };\n};\n","export default class QuickUnionFind {\n  constructor(nodes) {\n    this.disjointSets = nodes.reduce((accum, nodeId) => {\n      accum[nodeId] = nodeId;\n      return accum;\n    }, {});\n  }\n\n  connect(i, j) {\n    if (!this.isConnected(i, j)) {\n      let smallerOne = i;\n      let biggerOne = j;\n\n      if (j < i) {\n        smallerOne = j;\n        biggerOne = i;\n      }\n\n      this.disjointSets[this.findParent(biggerOne)] =\n        this.findParent(smallerOne);\n    }\n  }\n\n  findParent(i) {\n    const subParent = this.disjointSets[i];\n    if (parseInt(subParent) === parseInt(i)) {\n      return i;\n    }\n\n    this.disjointSets[i] = this.findParent(subParent);\n    return this.disjointSets[i];\n  }\n\n  isConnected(i, j) {\n    if (i === j) {\n      return true;\n    } else {\n      return this.findParent(i) === this.findParent(j);\n    }\n  }\n}\n","import { NUM_BOX } from \"../constants\";\nimport {\n  getIndexFromXY,\n  getPathNeighbor,\n  getXYFromIndex,\n  isValidLocation,\n  shuffle,\n} from \"./helper\";\nimport QuickUnionFind from \"./quickUnionFind\";\n\nexport const generateDfsMaze = (startNode, targetNode) => {\n  let initialPoint = Math.floor(Math.random() * (NUM_BOX - 1));\n  while (initialPoint === startNode || initialPoint === targetNode) {\n    initialPoint = Math.floor(Math.random() * (NUM_BOX - 1));\n  }\n\n  let visited = new Set();\n  let stack = [{ n: initialPoint }];\n  let path = [];\n\n  while (stack.length > 0) {\n    const pathIndex = stack.pop();\n\n    if (!visited.has(pathIndex.n)) {\n      pathIndex.w && path.push(pathIndex.w);\n      path.push(pathIndex.n);\n\n      visited.add(pathIndex.n);\n\n      const fullNeighbors = getPathNeighbor(pathIndex.n, 2);\n      const filteredNeighbors = fullNeighbors.filter(\n        (neighborId) => !visited.has(neighborId.n)\n      );\n      shuffle(filteredNeighbors);\n\n      filteredNeighbors.forEach((neighborId) => {\n        stack.push(neighborId);\n      });\n    }\n  }\n\n  path.reverse();\n  return path;\n};\n\nexport const generatePrimsMaze = (startNode, targetNode) => {\n  let initialPoint = Math.floor(Math.random() * (NUM_BOX - 1));\n  while (initialPoint === startNode || initialPoint === targetNode) {\n    initialPoint = Math.floor(Math.random() * (NUM_BOX - 1));\n  }\n\n  let visited = new Set();\n  let stack = [{ n: initialPoint }];\n  let path = [];\n\n  while (stack.length > 0) {\n    shuffle(stack);\n    const pathIndex = stack.pop();\n\n    if (!visited.has(pathIndex.n)) {\n      pathIndex.w && path.push(pathIndex.w);\n      path.push(pathIndex.n);\n\n      visited.add(pathIndex.n);\n\n      const fullNeighbors = getPathNeighbor(pathIndex.n, 2);\n      const filteredNeighbors = fullNeighbors.filter(\n        (neighborId) => !visited.has(neighborId.n)\n      );\n\n      filteredNeighbors.forEach((neighborId) => {\n        stack.push(neighborId);\n      });\n    }\n  }\n\n  path.reverse();\n  return path;\n};\n\nexport const generateRandomMaze = (startNode, targetNode) => {\n  const wallList = [];\n  for (let i = 0; i < NUM_BOX; i++) {\n    if (Math.random() < 0.35 && i !== startNode && i !== targetNode) {\n      wallList.push(i);\n    }\n  }\n\n  return wallList;\n};\n\nexport const generateBinaryMaze = (startNode, targetNode) => {\n  let { nodes: initialNodes } = generateUnconnectedNodes();\n  let path = [...initialNodes];\n\n  for (let i = 0; i < initialNodes.length; i++) {\n    const pos = getXYFromIndex(initialNodes[i]);\n    const westNode = { x: pos.x + 2, y: pos.y };\n    const southNode = { x: pos.x, y: pos.y + 2 };\n    const westPath = { x: pos.x + 1, y: pos.y };\n    const southPath = { x: pos.x, y: pos.y + 1 };\n\n    const isWestValidLocation = isValidLocation(westNode, {}, true);\n    const isNorthValidLocation = isValidLocation(southNode, {}, true);\n\n    if (isNorthValidLocation && !isWestValidLocation) {\n      path.push(getIndexFromXY(southPath));\n    } else if (!isNorthValidLocation && isWestValidLocation) {\n      path.push(getIndexFromXY(westPath));\n    } else if (isNorthValidLocation && isWestValidLocation) {\n      const r = Math.random();\n      if (r < 0.5) {\n        path.push(getIndexFromXY(southPath));\n      } else {\n        path.push(getIndexFromXY(westPath));\n      }\n    }\n  }\n\n  path.reverse();\n  return path;\n};\n\nexport const generateKruskalMaze = (startNode, targetNode) => {\n  let { nodes: initialNodes, walls } = generateUnconnectedNodes();\n  let path = [...initialNodes];\n  let quickUnionFind = new QuickUnionFind(initialNodes);\n  let wallList = [...walls];\n  shuffle(wallList);\n\n  let edgesCount = 0;\n  while (edgesCount < initialNodes.length - 1 && wallList.length > 0) {\n    const { wallIndex, n1Index, n2Index } = wallList.pop();\n\n    if (!quickUnionFind.isConnected(n1Index, n2Index)) {\n      path.push(wallIndex);\n      quickUnionFind.connect(n1Index, n2Index);\n      edgesCount += 1;\n    }\n  }\n\n  path.reverse();\n  return [...path];\n};\n\nexport const generateUnconnectedNodes = () => {\n  const possibleInitialConfiguration = [\n    { x: 0, y: 0 },\n    { x: 1, y: 0 },\n    { x: 0, y: 1 },\n    { x: 1, y: 1 },\n  ];\n\n  const startingPoint =\n    possibleInitialConfiguration[Math.floor(Math.random() * 4)];\n\n  let visited = new Set();\n  let nodes = [getIndexFromXY(startingPoint)];\n  let walls = new Set();\n  let stack = [getIndexFromXY(startingPoint)];\n  visited.add(getIndexFromXY(startingPoint));\n\n  while (stack.length > 0) {\n    const nIndex = stack.pop();\n    const neighbors = getPathNeighbor(nIndex, 2);\n\n    neighbors.forEach((neighbor) => {\n      if (!visited.has(neighbor.n)) {\n        stack.push(neighbor.n);\n        visited.add(neighbor.n);\n        nodes.push(neighbor.n);\n      }\n\n      walls.add({\n        wallIndex: neighbor.w,\n        n1Index: nIndex,\n        n2Index: neighbor.n,\n      });\n    });\n  }\n\n  return { nodes, walls };\n};\n","import React, { useState, useMemo, useReducer, useEffect } from \"react\";\nimport Heapify from \"heapify\";\nimport \"./App.css\";\nimport Box from \"./components/Box\";\nimport { algoReducer } from \"./reducer/reducer.js\";\nimport styled from \"styled-components\";\nimport {\n  EMPTY,\n  NUM_COL,\n  NUM_ROW,\n  START,\n  TARGET,\n  WALL,\n  DJIKSTRA,\n  NOT_VISITED,\n  SOLUTION,\n  DFS,\n  NUM_BOX,\n  DFS_MAZE,\n  RANDOM_MAZE,\n  BINARY_MAZE,\n  PRIMS_MAZE,\n  KRUSKAL_MAZE,\n} from \"./constants\";\nimport { algo } from \"./algorithm/algorithms\";\nimport DrawerBar from \"./DrawerBar\";\nimport {\n  initializeNodes,\n  resetNodeState,\n  clearNodes,\n  addRandomTrafficNodes,\n  clearNode,\n} from \"./algorithm/nodesFunction\";\nimport {\n  RUNNING,\n  SET_ALGO_STATUS,\n  SET_MAZE_GEN_STATUS,\n} from \"./reducer/actions\";\nimport { getIndexFromXY } from \"./algorithm/helper\";\nimport {\n  generateBinaryMaze,\n  generateDfsMaze,\n  generateKruskalMaze,\n  generatePrimsMaze,\n  generateRandomMaze,\n} from \"./algorithm/mazeGeneration\";\n\nconst TIME_INTERVAL = 1; // 1 mili\nconst START_NODE = getIndexFromXY({\n  x: Math.floor(NUM_COL / 2 - 8),\n  y: Math.floor(NUM_ROW / 2),\n});\nconst TARGET_NODE = getIndexFromXY({\n  x: Math.floor(NUM_COL / 2 + 8),\n  y: Math.floor(NUM_ROW / 2),\n});\n\nconst MazeRoot = styled.div`\n  display: grid;\n  grid-template-columns: repeat(${NUM_COL}, 1fr);\n  gap: 0 0;\n  width: 10px;\n  align-content: center;\n`;\n\nexport const StateContext = React.createContext();\nexport const DispatchContext = React.createContext();\n\nconst App = () => {\n  const [nodeList, setNodeList] = useState(\n    initializeNodes(START_NODE, TARGET_NODE, NUM_BOX)\n  );\n  const [startNode, setStartNode] = useState(START_NODE);\n  const [targetNode, setTargetNode] = useState(TARGET_NODE);\n  const [dragging, setDragging] = useState({ val: false });\n  const [intervalId, setIntervalId] = useState(0);\n  const [solutionList, setSolutionList] = useState([]);\n  const [wallList, setWallList] = useState([]);\n\n  const [state, dispatch] = useReducer(algoReducer, {\n    algo: DJIKSTRA,\n    step: 10,\n    maze_gen: DFS_MAZE,\n    maze_gen_status: false,\n  });\n\n  const boxList = useMemo(() => {\n    const boxList = [];\n    for (let i = 0; i < NUM_BOX; i++) {\n      boxList.push(i);\n    }\n\n    return boxList;\n  }, []);\n\n  const handleAddMaze = () => {\n    if (!state.maze_gen_status) {\n      dispatch({ type: SET_MAZE_GEN_STATUS, payload: true });\n      let pathList = [];\n      let inverse = false;\n      if (state.maze_gen === DFS_MAZE) {\n        pathList = generateDfsMaze(startNode, targetNode);\n        inverse = true;\n      } else if (state.maze_gen === RANDOM_MAZE) {\n        pathList = generateRandomMaze(startNode, targetNode);\n      } else if (state.maze_gen === BINARY_MAZE) {\n        pathList = generateBinaryMaze(startNode, targetNode);\n        inverse = true;\n      } else if (state.maze_gen === PRIMS_MAZE) {\n        pathList = generatePrimsMaze(startNode, targetNode);\n        inverse = true;\n      } else if (state.maze_gen === KRUSKAL_MAZE) {\n        pathList = generateKruskalMaze(startNode, targetNode);\n        inverse = true;\n      }\n\n      setNodeList((prevNodes) => clearNodes(prevNodes, inverse ? WALL : EMPTY));\n\n      setWallList(pathList);\n    } else {\n      dispatch({ type: SET_MAZE_GEN_STATUS, payload: false });\n    }\n  };\n\n  const handleClearNodes = () => {\n    setNodeList((prevNodes) => clearNodes(prevNodes));\n  };\n\n  const handleAddRandomTrafficNodes = () => {\n    setNodeList((prevNodes) => addRandomTrafficNodes(prevNodes));\n  };\n\n  const runAlgorithm = () => {\n    setSolutionList([]);\n\n    let distanceMap = { [startNode]: 0 };\n    let pathMap = { [startNode]: undefined };\n    let marked = new Set();\n    let pq = new Heapify(NUM_COL * NUM_ROW);\n    let lastVisited = [];\n    let deque = [startNode];\n\n    pq.push(startNode, 0);\n\n    if (intervalId) {\n      dispatch({ type: SET_ALGO_STATUS, payload: undefined });\n      clearInterval(intervalId);\n      setIntervalId(0);\n      return;\n    }\n\n    dispatch({ type: SET_ALGO_STATUS, payload: RUNNING });\n    let updatedNodeList = resetNodeState(nodeList);\n    const newIntervalId = setInterval(() => {\n      const algoMemoryObj =\n        state.algo === DFS\n          ? {\n              pathMap,\n              marked,\n              lastVisited,\n              deque,\n            }\n          : {\n              distanceMap,\n              pathMap,\n              marked,\n              pq,\n              lastVisited,\n            };\n\n      const {\n        solved: rSolved,\n        inProgress: rInProgress,\n        solution,\n        solutionList,\n        interimObj,\n      } = algo(\n        updatedNodeList,\n        startNode,\n        targetNode,\n        state.algo,\n        state.step,\n        algoMemoryObj\n      );\n\n      if (rInProgress) {\n        updatedNodeList = { ...solution };\n\n        pathMap = interimObj.pathMap;\n        marked = interimObj.marked;\n        lastVisited = interimObj.lastVisited;\n\n        if (state.algo !== DFS) {\n          pq = interimObj.pq;\n          distanceMap = interimObj.distanceMap;\n        } else {\n          deque = interimObj.deque;\n        }\n      }\n\n      (rSolved || rInProgress) && setNodeList(solution);\n\n      if (rSolved === true || (rSolved === false && rInProgress === false)) {\n        dispatch({ type: SET_ALGO_STATUS, payload: undefined });\n        clearInterval(newIntervalId);\n        setIntervalId(0);\n        if (solutionList) setSolutionList(solutionList);\n        return;\n      }\n    }, TIME_INTERVAL);\n\n    setIntervalId(newIntervalId);\n  };\n\n  // useEffect(() => {\n  //   let tempSolList = [...solutionList];\n  //   if (tempSolList.length !== 0) {\n  //     const interval = setInterval(() => {\n  //       setNodeList((prevNodeList) => {\n  //         const sIndex = tempSolList.pop();\n  //         prevNodeList[sIndex] = {\n  //           ...prevNodeList[sIndex],\n  //           state: SOLUTION,\n  //         };\n\n  //         return prevNodeList;\n  //       });\n\n  //       setSolutionList(tempSolList);\n\n  //       if (tempSolList.length === 0) {\n  //         clearInterval(interval);\n  //       }\n  //     }, TIME_INTERVAL);\n  //     return () => clearInterval(interval);\n  //   }\n  // }, [solutionList]);\n\n  useEffect(() => {\n    let temp = [...solutionList];\n    if (temp.length !== 0) {\n      setNodeList((prevNodeList) => {\n        let count = 0;\n        while (temp.length > 0 && count < Math.min(state.step / 2, 5)) {\n          const sIndex = temp.pop();\n          prevNodeList[sIndex] = {\n            ...prevNodeList[sIndex],\n            state: SOLUTION,\n          };\n          count += 1;\n        }\n\n        return prevNodeList;\n      });\n\n      setSolutionList(temp);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [solutionList]);\n\n  useEffect(() => {\n    const inverse =\n      [KRUSKAL_MAZE, DFS_MAZE, BINARY_MAZE, PRIMS_MAZE].indexOf(\n        state.maze_gen\n      ) !== -1;\n    let temp = [...wallList];\n\n    if (state.maze_gen_status) {\n      if (temp.length !== 0) {\n        setNodeList((prevNodeList) => {\n          let count = 0;\n          while (temp.length > 0 && count < state.step) {\n            const sIndex = temp.pop();\n            prevNodeList[sIndex] = clearNode(\n              prevNodeList[sIndex],\n              inverse ? EMPTY : WALL\n            );\n            count += 1;\n          }\n\n          return prevNodeList;\n        });\n\n        setWallList(temp);\n      } else {\n        dispatch({ type: SET_MAZE_GEN_STATUS, payload: false });\n        setWallList([]);\n      }\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [wallList, state.maze_gen_status]);\n\n  const handleClick = (i) => (e) => {\n    const currentType = nodeList[i].type;\n    let nextType = currentType;\n    let nextState = nodeList[i].state;\n\n    if (!dragging.val) {\n      if (\n        currentType !== TARGET &&\n        currentType !== START &&\n        currentType !== WALL\n      ) {\n        nextType = WALL;\n        nextState = NOT_VISITED;\n      } else if (currentType === WALL) {\n        nextType = EMPTY;\n        nextState = NOT_VISITED;\n      } else if (currentType === TARGET || currentType === START) {\n        setDragging({ val: true, type: currentType });\n      }\n    } else {\n      if (currentType !== WALL) {\n        nextState = NOT_VISITED;\n        nextType = dragging.type;\n        if (dragging.type === TARGET) {\n          setTargetNode(i);\n        } else if (dragging.type === START) {\n          setStartNode(i);\n        }\n      }\n\n      setDragging({ val: false });\n    }\n\n    nextType &&\n      setNodeList({\n        ...nodeList,\n        [i]: {\n          ...nodeList[i],\n          type: nextType,\n          state: nextState,\n        },\n      });\n  };\n\n  const updateDraggedNode = (node) => {\n    if (dragging.val && nodeList[node].type !== WALL) {\n      const updateNode = dragging.type === START ? startNode : targetNode;\n      setNodeList({\n        ...nodeList,\n        [node]: {\n          ...nodeList[node],\n          type: dragging.type,\n          state: NOT_VISITED,\n        },\n        [updateNode]: {\n          ...nodeList[updateNode],\n          type: EMPTY,\n          state: NOT_VISITED,\n        },\n      });\n\n      if (dragging.type === TARGET) {\n        setTargetNode(node);\n      } else if (dragging.type === START) {\n        setStartNode(node);\n      }\n    }\n  };\n\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state}>\n        <div>\n          <div style={{ display: \"flex\" }}>\n            <MazeRoot>\n              {boxList.map((index) => (\n                <Box\n                  key={index}\n                  node={index}\n                  type={nodeList[index]?.type}\n                  state={nodeList[index]?.state}\n                  handleClick={handleClick(index)}\n                  updateDraggedNode={updateDraggedNode}\n                />\n              ))}\n            </MazeRoot>\n          </div>\n\n          <DrawerBar\n            onRunAlgoClick={runAlgorithm}\n            handleClearNodes={handleClearNodes}\n            handleAddRandomTrafficNodes={handleAddRandomTrafficNodes}\n            handleAddMaze={handleAddMaze}\n          />\n        </div>\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n};\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}